using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// CodeMonkey heavily referenced for most of this system.
public class GridCombatSystem : MonoBehaviour
{
    [SerializeField] private UnitGridCombat[] unitGridCombatArray;          // List of characters on the arena
    private UnitGridCombat selectedUnit;                                    // The character that is currently selected by the player

    private State state;                                                    // State of the game. Whose turn is it? Are we setting everything up? Has it ended?

    private List<UnitGridCombat> playerTeamList;                            // The list of characters the player has control of.
    private List<UnitGridCombat> AITeamList;                                // The list of character the AI has control of.

    private int strengthPoints, healthPoints, movementPoints, aoePoints;    // Points generated by selecting cards.
    private bool hasClicked;                                                // Avoid player doing moves multiple times
    CardManager cardManager;                                                // Relay info about cards to GridCombatSystem. (Updating the points is currently in Card... update to be here for clarity?)

    private enum State 
    { 
        Begin,
        PlayerTurn,
        AITurn,
        Win,
        Lost
    }

    private void Awake()
    {
        state = State.Begin;
        StartCoroutine(BeginBattle());
    }

    private void Start()
    {
        foreach (UnitGridCombat unitGridCombat in unitGridCombatArray) {
            ArenaHandler.Instance.GetGrid().GetGridObject(unitGridCombat.GetPosition());
        }
        Grid<PathNode> grid = ArenaHandler.Instance.GetGrid();
        Pathfinding pathfinding = ArenaHandler.Instance.pathfinding;
        cardManager = FindObjectOfType<CardManager>();
    }

    private void Update() // This is where we will check for what the player clicks on and such
    {
        if (state != State.PlayerTurn) return;
        
        if (Input.GetMouseButtonUp(0))
        {                                                                          // Change to our standard player input later
            Grid<PathNode> grid = ArenaHandler.Instance.GetGrid();
            PathNode node = grid.GetGridObject(Camera.main.ScreenToWorldPoint(Input.mousePosition));    // Again, change to fit in with other methods (Possible?)
            if (node.GetUnitGridCombat() != null) {
                // Clicked on a unit,
                if (selectedUnit.IsEnemy(node.GetUnitGridCombat())) {
                    // The unit that the player clicked on is an enemy
                    if (strengthPoints > 0 && selectedUnit.CanAttackUnit(node.GetUnitGridCombat())) {
                        // Player has enough strength to attack
                        // Queue the attack
                        Debug.Log("You can attack");
                    }
                    else { 
                        Debug.Log("Not strong enough or out of range"); 
                    }
                }
                else { 
                    Debug.Log("Clicked on ally");
                }
            }
            else { 
                Debug.Log("Not a unit"); 
            }

            if (selectedUnit.CanMoveTile(node))
            {
                // Is a valid move position
                if (movementPoints >= selectedUnit.GetDistance(node)) {
                    // Have enough points to move there
                    // Queue the movement
                    Debug.Log("You can move");
                }
                else {
                    Debug.Log("Invalid movement location");
                }
            }
        }
    }

    IEnumerator BeginBattle() // Sets up everything for the fight.
    {
        // Move to the player's turn
        state = State.PlayerTurn;
        yield return StartCoroutine(PlayerTurn());
    }

    IEnumerator PlayerTurn() {
        // Display a message stating that it is the player's turn.
        Debug.Log("Player's turn");
        yield return new WaitForSeconds(1);
        hasClicked = false;
    }

    public void PlayerButtonPressed() 
    {
        // Don't allow player to perform an action on a turn that is not their own.
        if (state != State.PlayerTurn)
            return;

        // Allow only a single action per turn
        if (!hasClicked)
        {
            StartCoroutine(PlayerActions());
            // Block user from repeatedly pressing attack button
            hasClicked = true;
        }
    }

    IEnumerator PlayerActions() 
    {
        // Iterate through list of moves, trigger execution
        // Animate as well
        foreach (UnitGridCombat chara in playerTeamList) {
            // Do each move that this character wants to do

            yield return new WaitForSeconds(1); // Wait and switch to next character
        }
        yield return new WaitForSeconds(2);

        // If player still has a character alive, move to AI Turn
        state = State.AITurn;
        yield return StartCoroutine(AITurn());
    }

    // Each time a card is selected or deselected, update some information
    public void CardSelected(Card card) 
    {
        AddPoints(card.cardData.strength,card.cardData.health,card.cardData.movement,card.cardData.aoe);

        foreach (UnitGridCombat chara in playerTeamList)
            chara.UpdateValidity(movementPoints);
    
    }

    public void CardDeselected(Card card) 
    {
        AddPoints(-card.cardData.strength, -card.cardData.health, -card.cardData.movement, -card.cardData.aoe);

        foreach (UnitGridCombat chara in playerTeamList)
            chara.UpdateValidity(movementPoints);

    }

    IEnumerator AITurn()
    {
        Debug.Log("AI Turn");

        // If AI still has a character alive, move to player Turn
        state = State.PlayerTurn;
        yield return StartCoroutine(PlayerTurn());
    }


    // Add points the player uses to make moves
    public void AddPoints(int strengthPoints, int healthPoints, int movementPoints, int aoePoints) 
    {
        this.strengthPoints += strengthPoints;
        this.healthPoints += healthPoints;
        this.movementPoints += movementPoints;
        this.aoePoints += aoePoints;
    }

}
